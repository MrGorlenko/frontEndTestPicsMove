<template>
  <div class="product-list">
    <!-- СТАРАЯ ВЕРСИЯ -->
    <!-- <div
      class="card"
      v-for="product in products"
      :style="{ width: cardsWidth + '%' }"   
    > -->
    <!-- СТАРАЯ ВЕРСИЯ -->
    <!-- НОВАЯ ВЕРСИЯ -->
    <!-- <div
      class="card"
      v-for="product in products"
      :key="product.id"
      :style="{ width: cardsWidth + '%' }"
    > -->
    <!-- Не было :key, был добавлен -->
    <!-- НОВАЯ ВЕРСИЯ -->

    <!-- <p class="card-title">{{ product.title }}</p>
      <img class="card-image" :src="product.image" alt="" />
      <p class="card-price">Цена: {{ product.price }} {{ currency }}</p>

      <div>
        <input v-model="amount" type="number" ref="amount" :id="product.id" /> -->
    <!-- для получения значения из инпута не будет использоваться ref, вместо этого лучше взять v-model='' -->
    <!-- однако использование v-model здесь повлечет за собой ситуацию, когда изменение инпута у одного товара, будет изменять инпуты и у других товаров тоже -->
    <!-- Так происходит из-за глобальной архитектурной ошибки. Тут находит и обертка листа и сам цикл v-for в котором уже установлен v-model у инпута -->
    <!-- Для решения этой проблемы стоило бы вынести card в отдельную компоненту и произвести циклический вывод уже непосредственно самой компоненты -->
    <!-- Это изолирует v-model до каждого конкретного экземпляра  -->
    <!-- Также инпут не должен позволять выбрать отрицательное количество элементов, необходимо установить 
      аттрибут min="0" (или 1)  -->
    <!-- <span>кг</span>
      </div>

      <button @click="addToCart(product)">В корзину</button>
    </div> -->

    <!-- Обертка теоретически может быть использована для других нужд,
    поэтому лучше использовать принцип "композиция вместо наследования"
    и поставить сюда слот для того чтобы использовать эту обертку тогда,
    когда необходимо и где необходимо, убирая зависимость от списка конкретных 
    элементов  -->
    <slot></slot>
  </div>
</template>

<script>
export default {
  // props: {
  //   currency: String,
  // },
  // data() {
  //   return {
  //     products: [],
  //     amount: 0, //
  //   };
  // },
  // computed: {
  //   cardsWidth() {
  //     let width = window.innerWidth;
  //     let count = 1;
  //     // СТАРАЯ ВЕРСИЯ
  //     // if (width > '840px') {
  //     //   count = 3;
  //     // } else if ((width > '420px' && width < '840px')) {
  //     //   count = 2;
  //     // }
  //     // СТАРАЯ ВЕРСИЯ
  //     // НОВАЯ ВЕРСИЯ
  //     if (width > 840) {
  //       count = 3;
  //     } else if (width > 420 && width < 840) {
  //       count = 2;
  //     }
  //     // НОВАЯ ВЕРСИЯ
  //     //не нужны px так как свойство innerWidth по умолчанию считает свою величину в пикселях, о чем написано в документации DOM.
  //     //кроме того, не обязательны даже ковычки, так как js умеет воспринимать числа в ковычках как обычные numbers
  //     return 100 / count;
  //   },
  // },
  // methods: {
  //   startPricesMonitoring() {
  //     setInterval(this.getList, 1000);
  //   },
  //   async getList() {
  //     let data = await this.$store.dispatch("getProductsList"); // данный action не является ассинхронным. В документе /store/index.js данный action
  //     // не возвращает никаких промисов, а значит, await здесь не сыграет никакой роли.
  //     // если будет запрос на настоящий сервер, то this.products = data произойдет раньше,
  //     // чем будет окончено action getProductsList и даже await не спасет
  //     // мое личное предпочтение использовать тут не await, а комбинацию
  //     // .then((response)=>{}).catch((error)=>{})
  //     // так как это позволит утловить ошибку прям тут в темплейте и в случае сбоя, вместо
  //     // выведения списка продуктов, показать сообщение о случившейся ошибке
  //     this.products = data;
  //   },
  //   addToCart(product) {
  //     // let amount = this.$refs.amount.find(
  //     //   (input) => input.id === product.id
  //     // ).value; // во фреймворках типа vue или библиотеке react не рекомендуется обращаться к инпутам через ref для получения значения этого
  //     // инпута. Во vue есть очень удобный v-model атрибут, которые позволит произвести bind данных напрямую прямо в data(){return{ ... }}
  //     // а затем по прямому обращению к данному значению его можно использовать
  //     // Более того, amount не переопределяется нигде в этом методе, следовательно лучше будет определить его как const
  //     const amount = this.amount;
  //     const price = product.price;
  //     const title = product.title;
  //     // Еще лучше создать отдельные переменные для передачи в объект сразу три значения без указания пары ключ-значение, это повысит читабельность кода
  //     let data = {
  //       amount,
  //       price,
  //       title, // Новая спецификация js позволяет не указывать ключи в объектах в том случае, если ключ и значение совпадают
  //       // price: product.price,
  //       // title: product.title,
  //     };
  //     this.$parent.cart.push(data);
  //   },
  // },
  // created() {
  //   this.startPricesMonitoring();
  // },
  // ТАКИМ ОБРАЗОМ, ДАННЫЙ КОМПОНЕНТ СЛУЖИТ ИМЕННО ОБЕРТКОЙ И НИЧЕМ БОЛЬШЕ
};
</script>

<style>
.product-list {
  padding: 10px;
}
</style>
